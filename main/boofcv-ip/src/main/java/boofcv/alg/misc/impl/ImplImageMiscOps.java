/*
 * Copyright (c) 2011-2019, Peter Abeles. All Rights Reserved.
 *
 * This file is part of BoofCV (http://boofcv.org).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package boofcv.alg.misc.impl;

import boofcv.alg.misc.ImageMiscOps;
import boofcv.struct.border.ImageBorder_F32;
import boofcv.struct.border.ImageBorder_F64;
import boofcv.struct.border.ImageBorder_S32;
import boofcv.struct.border.ImageBorder_S64;
import boofcv.struct.image.*;

import javax.annotation.Generated;

/**
 * Implementations of functions for {@link ImageMiscOps}
 *
 * <p>
 * DO NOT MODIFY. This code was automatically generated by GenerateImplImageMiscOps.
 * <p>
 *
 * @author Peter Abeles
 */
@Generated("boofcv.alg.misc.impl.GenerateImplImageMiscOps")
public class ImplImageMiscOps {

	public static <T extends GrayI8<T>>
	void growBorder(T src , ImageBorder_S32<T> border, int radiusX, int radiusY , T dst )
	{
		dst.reshape(src.width+2*radiusX, src.height+2*radiusY);
		border.setImage(src);

		// Copy src into the inner portion of dst
		ImageMiscOps.copy(0,0,radiusX,radiusY,src.width,src.height,src,dst);

		// Top border
		for (int y = 0; y < radiusY; y++) {
			int idxDst = dst.startIndex + y*dst.stride;
			for (int x = 0; x < dst.width; x++) {
				dst.data[idxDst++] = (byte)border.get(x-radiusX,y-radiusY);
			}
		}
		// Bottom border
		for (int y = 0; y < radiusY; y++) {
			int idxDst = dst.startIndex + (dst.height-radiusY+y)*dst.stride;
			for (int x = 0; x < dst.width; x++) {
				dst.data[idxDst++] = (byte)border.get(x-radiusX,src.height+y);
			}
		}
		// Left and right border
		for (int y = radiusY; y < dst.height-radiusY; y++) {
			int idxDst = dst.startIndex + y*dst.stride;
			for (int x = 0; x < radiusX; x++) {
				dst.data[idxDst++] = (byte)border.get(x-radiusX,y-radiusY);
			}
			idxDst = dst.startIndex + y*dst.stride+src.width+radiusX;
			for (int x = 0; x < radiusX; x++) {
				dst.data[idxDst++] = (byte)border.get(src.width+x,y-radiusY);
			}
		}
	}

	public static <T extends GrayI16<T>>
	void growBorder(T src , ImageBorder_S32<T> border, int radiusX, int radiusY , T dst )
	{
		dst.reshape(src.width+2*radiusX, src.height+2*radiusY);
		border.setImage(src);

		// Copy src into the inner portion of dst
		ImageMiscOps.copy(0,0,radiusX,radiusY,src.width,src.height,src,dst);

		// Top border
		for (int y = 0; y < radiusY; y++) {
			int idxDst = dst.startIndex + y*dst.stride;
			for (int x = 0; x < dst.width; x++) {
				dst.data[idxDst++] = (short)border.get(x-radiusX,y-radiusY);
			}
		}
		// Bottom border
		for (int y = 0; y < radiusY; y++) {
			int idxDst = dst.startIndex + (dst.height-radiusY+y)*dst.stride;
			for (int x = 0; x < dst.width; x++) {
				dst.data[idxDst++] = (short)border.get(x-radiusX,src.height+y);
			}
		}
		// Left and right border
		for (int y = radiusY; y < dst.height-radiusY; y++) {
			int idxDst = dst.startIndex + y*dst.stride;
			for (int x = 0; x < radiusX; x++) {
				dst.data[idxDst++] = (short)border.get(x-radiusX,y-radiusY);
			}
			idxDst = dst.startIndex + y*dst.stride+src.width+radiusX;
			for (int x = 0; x < radiusX; x++) {
				dst.data[idxDst++] = (short)border.get(src.width+x,y-radiusY);
			}
		}
	}

	public static void growBorder(GrayS32 src , ImageBorder_S32 border, int radiusX, int radiusY , GrayS32 dst )
	{
		dst.reshape(src.width+2*radiusX, src.height+2*radiusY);
		border.setImage(src);

		// Copy src into the inner portion of dst
		ImageMiscOps.copy(0,0,radiusX,radiusY,src.width,src.height,src,dst);

		// Top border
		for (int y = 0; y < radiusY; y++) {
			int idxDst = dst.startIndex + y*dst.stride;
			for (int x = 0; x < dst.width; x++) {
				dst.data[idxDst++] = border.get(x-radiusX,y-radiusY);
			}
		}
		// Bottom border
		for (int y = 0; y < radiusY; y++) {
			int idxDst = dst.startIndex + (dst.height-radiusY+y)*dst.stride;
			for (int x = 0; x < dst.width; x++) {
				dst.data[idxDst++] = border.get(x-radiusX,src.height+y);
			}
		}
		// Left and right border
		for (int y = radiusY; y < dst.height-radiusY; y++) {
			int idxDst = dst.startIndex + y*dst.stride;
			for (int x = 0; x < radiusX; x++) {
				dst.data[idxDst++] = border.get(x-radiusX,y-radiusY);
			}
			idxDst = dst.startIndex + y*dst.stride+src.width+radiusX;
			for (int x = 0; x < radiusX; x++) {
				dst.data[idxDst++] = border.get(src.width+x,y-radiusY);
			}
		}
	}

	public static void growBorder(GrayS64 src , ImageBorder_S64 border, int radiusX, int radiusY , GrayS64 dst )
	{
		dst.reshape(src.width+2*radiusX, src.height+2*radiusY);
		border.setImage(src);

		// Copy src into the inner portion of dst
		ImageMiscOps.copy(0,0,radiusX,radiusY,src.width,src.height,src,dst);

		// Top border
		for (int y = 0; y < radiusY; y++) {
			int idxDst = dst.startIndex + y*dst.stride;
			for (int x = 0; x < dst.width; x++) {
				dst.data[idxDst++] = border.get(x-radiusX,y-radiusY);
			}
		}
		// Bottom border
		for (int y = 0; y < radiusY; y++) {
			int idxDst = dst.startIndex + (dst.height-radiusY+y)*dst.stride;
			for (int x = 0; x < dst.width; x++) {
				dst.data[idxDst++] = border.get(x-radiusX,src.height+y);
			}
		}
		// Left and right border
		for (int y = radiusY; y < dst.height-radiusY; y++) {
			int idxDst = dst.startIndex + y*dst.stride;
			for (int x = 0; x < radiusX; x++) {
				dst.data[idxDst++] = border.get(x-radiusX,y-radiusY);
			}
			idxDst = dst.startIndex + y*dst.stride+src.width+radiusX;
			for (int x = 0; x < radiusX; x++) {
				dst.data[idxDst++] = border.get(src.width+x,y-radiusY);
			}
		}
	}

	public static void growBorder(GrayF32 src , ImageBorder_F32 border, int radiusX, int radiusY , GrayF32 dst )
	{
		dst.reshape(src.width+2*radiusX, src.height+2*radiusY);
		border.setImage(src);

		// Copy src into the inner portion of dst
		ImageMiscOps.copy(0,0,radiusX,radiusY,src.width,src.height,src,dst);

		// Top border
		for (int y = 0; y < radiusY; y++) {
			int idxDst = dst.startIndex + y*dst.stride;
			for (int x = 0; x < dst.width; x++) {
				dst.data[idxDst++] = border.get(x-radiusX,y-radiusY);
			}
		}
		// Bottom border
		for (int y = 0; y < radiusY; y++) {
			int idxDst = dst.startIndex + (dst.height-radiusY+y)*dst.stride;
			for (int x = 0; x < dst.width; x++) {
				dst.data[idxDst++] = border.get(x-radiusX,src.height+y);
			}
		}
		// Left and right border
		for (int y = radiusY; y < dst.height-radiusY; y++) {
			int idxDst = dst.startIndex + y*dst.stride;
			for (int x = 0; x < radiusX; x++) {
				dst.data[idxDst++] = border.get(x-radiusX,y-radiusY);
			}
			idxDst = dst.startIndex + y*dst.stride+src.width+radiusX;
			for (int x = 0; x < radiusX; x++) {
				dst.data[idxDst++] = border.get(src.width+x,y-radiusY);
			}
		}
	}

	public static void growBorder(GrayF64 src , ImageBorder_F64 border, int radiusX, int radiusY , GrayF64 dst )
	{
		dst.reshape(src.width+2*radiusX, src.height+2*radiusY);
		border.setImage(src);

		// Copy src into the inner portion of dst
		ImageMiscOps.copy(0,0,radiusX,radiusY,src.width,src.height,src,dst);

		// Top border
		for (int y = 0; y < radiusY; y++) {
			int idxDst = dst.startIndex + y*dst.stride;
			for (int x = 0; x < dst.width; x++) {
				dst.data[idxDst++] = border.get(x-radiusX,y-radiusY);
			}
		}
		// Bottom border
		for (int y = 0; y < radiusY; y++) {
			int idxDst = dst.startIndex + (dst.height-radiusY+y)*dst.stride;
			for (int x = 0; x < dst.width; x++) {
				dst.data[idxDst++] = border.get(x-radiusX,src.height+y);
			}
		}
		// Left and right border
		for (int y = radiusY; y < dst.height-radiusY; y++) {
			int idxDst = dst.startIndex + y*dst.stride;
			for (int x = 0; x < radiusX; x++) {
				dst.data[idxDst++] = border.get(x-radiusX,y-radiusY);
			}
			idxDst = dst.startIndex + y*dst.stride+src.width+radiusX;
			for (int x = 0; x < radiusX; x++) {
				dst.data[idxDst++] = border.get(src.width+x,y-radiusY);
			}
		}
	}

}
